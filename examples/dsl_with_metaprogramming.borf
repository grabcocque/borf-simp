-- Building Domain-Specific Languages with Borf Metaprogramming
-- This file demonstrates how to use Borf's metaprogramming capabilities to create DSLs

import prim
import syntax

--[[ 
  This example shows how to use Borf's metaprogramming capabilities to:
  1. Create domain-specific languages (DSLs) within Borf
  2. Use quasiquoting and macros to extend the language
  3. Create syntax transformations that enable new programming patterns
]]--

module dsl_meta

-- =============================================
-- Example 1: Query DSL for data manipulation
-- =============================================

-- Define the data model type
make_data_model_type [->
  #{
    collections: Map[String, Collection],
    relationships: List[Relationship]
  }
] : Type

-- Define the collection type
make_collection_type [->
  #{
    name: String,
    fields: Map[String, Field],
    records: List[Record]
  }
] : Type

-- Define the field type
make_field_type [->
  #{
    name: String,
    type: FieldType,
    required: Bool
  }
] : Type

-- Define the field type enumeration
make_field_type_enum [->
  #{
    String: Unit,
    Number: Unit,
    Boolean: Unit,
    DateTime: Unit,
    Reference: String  -- Name of the referenced collection
  }
] : Type

-- Define the relationship type
make_relationship_type [->
  #{
    from: String,  -- Collection name
    to: String,    -- Collection name
    type: RelationshipType,
    name: String
  }
] : Type

-- Define the relationship type enumeration
make_relationship_type_enum [->
  #{
    OneToOne: Unit,
    OneToMany: Unit,
    ManyToMany: Unit
  }
] : Type

-- Define the record type
make_record_type [->
  #{
    id: String,
    values: Map[String, Value]
  }
] : Type

-- Create the concrete types from the generators
type DataModel => $make_data_model_type()
type Collection => $make_collection_type()
type Field => $make_field_type()
type FieldType => $make_field_type_enum()
type Relationship => $make_relationship_type()
type RelationshipType => $make_relationship_type_enum()
type Record => $make_record_type()

-- DSL syntax for defining a data model
define_model [model_body: Code ->
  -- Extract the model definition from the code block
  `{
    -- Initialize an empty model
    model -> {
      collections: {},
      relationships: []
    }
    
    -- Process the model body code to build the model
    $model_body
    
    -- Return the constructed model
    model
  }
] : Code

-- DSL syntax for defining a collection
define_collection [name: String, fields_code: Code ->
  -- Generate the collection definition code
  `{
    -- Initialize a new collection
    collection -> {
      name: $name,
      fields: {},
      records: []
    }
    
    -- Process fields code
    $fields_code
    
    -- Add the collection to the model
    model.collections <- model.collections |> insert($name, collection)
  }
] : Code

-- DSL syntax for defining a field
define_field [name: String, type_expr: Code, required: Bool ->
  -- Generate the field definition code
  `{
    -- Create the field
    field -> {
      name: $name,
      type: $type_expr,
      required: $required
    }
    
    -- Add the field to the current collection
    collection.fields <- collection.fields |> insert($name, field)
  }
] : Code

-- DSL syntax for defining a relationship
define_relationship [from: String, to: String, rel_type: Code, name: String ->
  -- Generate the relationship definition code
  `{
    -- Create the relationship
    relationship -> {
      from: $from,
      to: $to,
      type: $rel_type,
      name: $name
    }
    
    -- Add the relationship to the model
    model.relationships <- model.relationships + [relationship]
  }
] : Code

-- DSL for querying the model
query [model: DataModel, collection_name: String ->
  -- Create a query builder
  `{
    -- Get the collection to query
    collection -> model.collections[$collection_name]
    
    -- Initialize an empty query result
    result -> collection.records
    
    -- Return a query builder object
    {
      -- Filter records by a predicate
      where: [predicate -> 
        result <- result |> filter(predicate)
        self  -- Return self for chaining
      ],
      
      -- Sort records by a field
      order_by: [field, ascending -> 
        result <- result |> sort_by([record -> record.values[field]], ascending)
        self  -- Return self for chaining
      ],
      
      -- Limit the number of results
      limit: [count -> 
        result <- result |> take(count)
        self  -- Return self for chaining
      ],
      
      -- Execute the query and return results
      execute: [-> result]
    }
  }
] : Code

-- Example usage of the data model DSL
example_data_model [->
  -- Create a data model using our DSL
  model -> define_model({
    -- Define the User collection
    define_collection("User", {
      define_field("username", { String: () }, true)
      define_field("email", { String: () }, true)
      define_field("active", { Boolean: () }, true)
      define_field("created_at", { DateTime: () }, true)
    })
    
    -- Define the Post collection
    define_collection("Post", {
      define_field("title", { String: () }, true)
      define_field("content", { String: () }, true)
      define_field("author", { Reference: "User" }, true)
      define_field("published", { Boolean: () }, false)
    })
    
    -- Define the relationships
    define_relationship("User", "Post", { OneToMany: () }, "posts")
    define_relationship("Post", "User", { OneToOne: () }, "author")
  })
  
  -- Now we can query the model using our query DSL
  -- This is just a demonstration of what the code would look like
  
  users_query -> query(model, "User") |>
    where([user -> user.values["active"] == true]) |>
    order_by("created_at", false) |>
    limit(10)
  
  active_users -> users_query |> execute()
  
  posts_query -> query(model, "Post") |>
    where([post -> post.values["published"] == true]) |>
    order_by("title", true)
  
  published_posts -> posts_query |> execute()
  
  "Data model created with " + (model.collections |> length) + " collections"
] : String

-- =============================================
-- Example 2: State Machine DSL 
-- =============================================

-- Define state machine types
make_state_machine_type [->
  #{
    name: String,
    initial_state: String,
    states: Map[String, State],
    transitions: List[Transition]
  }
] : Type

make_state_type [->
  #{
    name: String,
    on_entry: ?Code,
    on_exit: ?Code
  }
] : Type

make_transition_type [->
  #{
    name: String,
    from: String,
    to: String,
    guard: ?Code,
    action: ?Code
  }
] : Type

-- Create the concrete types
type StateMachine => $make_state_machine_type()
type State => $make_state_type()
type Transition => $make_transition_type()

-- DSL for defining a state machine
define_state_machine [name: String, initial_state: String, sm_body: Code ->
  `{
    -- Initialize the state machine
    sm -> {
      name: $name,
      initial_state: $initial_state,
      states: {},
      transitions: []
    }
    
    -- Process the state machine body code
    $sm_body
    
    -- Return the constructed state machine
    sm
  }
] : Code

-- DSL for defining a state
define_state [name: String, on_entry: ?Code, on_exit: ?Code ->
  `{
    -- Create the state
    state -> {
      name: $name,
      on_entry: $on_entry,
      on_exit: $on_exit
    }
    
    -- Add the state to the state machine
    sm.states <- sm.states |> insert($name, state)
  }
] : Code

-- DSL for defining a transition
define_transition [name: String, from: String, to: String, guard: ?Code, action: ?Code ->
  `{
    -- Create the transition
    transition -> {
      name: $name,
      from: $from,
      to: $to,
      guard: $guard,
      action: $action
    }
    
    -- Add the transition to the state machine
    sm.transitions <- sm.transitions + [transition]
  }
] : Code

-- Runtime state machine execution
create_state_machine_instance [sm: StateMachine, context: Map ->
  `{
    -- Create a new instance with the initial state
    instance -> {
      state_machine: $sm,
      current_state: sm.initial_state,
      context: $context,
      history: [sm.initial_state]
    }
    
    -- Call the on_entry action for the initial state
    initial_state -> sm.states[sm.initial_state]
    if initial_state.on_entry is some then
      initial_state.on_entry |> unwrap |> eval(context)
    
    -- Return the instance
    instance
  }
] : Code

-- Trigger a transition on a state machine instance
trigger [instance: Map, event: String ->
  `{
    -- Find applicable transitions from the current state
    sm -> instance.state_machine
    current_state -> instance.current_state
    context -> instance.context
    
    -- Find valid transitions for this event
    valid_transitions -> sm.transitions |> filter [t -> 
      t.name == $event and t.from == current_state
    ]
    
    -- Find the first transition whose guard condition passes
    transition -> valid_transitions |> find [t ->
      -- If no guard, transition is valid
      if t.guard is nothing then
        true
      else
        -- Evaluate the guard with the context
        t.guard |> unwrap |> eval(context) |> is_truthy
    ]
    
    -- If we found a valid transition, execute it
    if transition is some then {
      t -> transition |> unwrap
      
      -- Execute exit action of current state
      if sm.states[current_state].on_exit is some then
        sm.states[current_state].on_exit |> unwrap |> eval(context)
      
      -- Execute the transition action
      if t.action is some then
        t.action |> unwrap |> eval(context)
      
      -- Update the current state
      instance.current_state <- t.to
      instance.history <- instance.history + [t.to]
      
      -- Execute entry action of new state
      if sm.states[t.to].on_entry is some then
        sm.states[t.to].on_entry |> unwrap |> eval(context)
      
      -- Return true to indicate transition occurred
      true
    } else {
      -- No valid transition found
      false
    }
  }
] : Code

-- Example usage of the state machine DSL
example_state_machine [->
  -- Create a traffic light state machine
  traffic_light -> define_state_machine("TrafficLight", "Red", {
    -- Define states
    define_state("Red", 
      some(`{ println("Light turned RED - Stop!") }`), 
      some(`{ println("Exiting Red state") }`)
    )
    
    define_state("Yellow", 
      some(`{ println("Light turned YELLOW - Prepare to stop") }`),
      some(`{ println("Exiting Yellow state") }`)
    )
    
    define_state("Green", 
      some(`{ println("Light turned GREEN - Go!") }`),
      some(`{ println("Exiting Green state") }`)
    )
    
    -- Define transitions
    define_transition("next", "Red", "Green", nothing, 
      some(`{ context.last_changed <- current_time() }`)
    )
    
    define_transition("next", "Green", "Yellow", nothing, 
      some(`{ context.last_changed <- current_time() }`)
    )
    
    define_transition("next", "Yellow", "Red", nothing, 
      some(`{ context.last_changed <- current_time() }`)
    )
  })
  
  -- Create an instance of the traffic light state machine
  light -> create_state_machine_instance(traffic_light, { count: 0 })
  
  -- Trigger state changes
  trigger(light, "next")  -- Red -> Green
  trigger(light, "next")  -- Green -> Yellow
  trigger(light, "next")  -- Yellow -> Red
  
  "Traffic light state machine with " + (traffic_light.states |> length) + " states"
] : String

-- =============================================
-- Example 3: Web API DSL
-- =============================================

-- Define API types
make_api_type [->
  #{
    name: String,
    endpoints: List[Endpoint],
    middleware: List[Middleware]
  }
] : Type

make_endpoint_type [->
  #{
    path: String,
    method: HttpMethod,
    handler: Code,
    middleware: List[Middleware]
  }
] : Type

make_middleware_type [->
  #{
    name: String,
    handler: Code
  }
] : Type

make_http_method_enum [->
  #{
    GET: Unit,
    POST: Unit,
    PUT: Unit,
    DELETE: Unit,
    PATCH: Unit
  }
] : Type

-- Create the concrete types
type Api => $make_api_type()
type Endpoint => $make_endpoint_type()
type Middleware => $make_middleware_type()
type HttpMethod => $make_http_method_enum()

-- DSL for defining an API
define_api [name: String, api_body: Code ->
  `{
    -- Initialize the API
    api -> {
      name: $name,
      endpoints: [],
      middleware: []
    }
    
    -- Process the API body code
    $api_body
    
    -- Return the constructed API
    api
  }
] : Code

-- DSL for defining an endpoint
endpoint [path: String, method: HttpMethod, handler: Code ->
  `{
    -- Create the endpoint
    ep -> {
      path: $path,
      method: $method,
      handler: $handler,
      middleware: []
    }
    
    -- Add the endpoint to the API
    api.endpoints <- api.endpoints + [ep]
  }
] : Code

-- DSL for defining middleware
use_middleware [name: String, handler: Code ->
  `{
    -- Create the middleware
    mw -> {
      name: $name,
      handler: $handler
    }
    
    -- Add the middleware to the API
    api.middleware <- api.middleware + [mw]
  }
] : Code

-- Add middleware to a specific endpoint
apply_middleware [endpoint_path: String, middleware_name: String ->
  `{
    -- Find the middleware
    mw -> api.middleware |> find [m -> m.name == $middleware_name] |> unwrap
    
    -- Find the endpoint and add the middleware
    api.endpoints <- api.endpoints |> map [ep ->
      if ep.path == $endpoint_path then
        { ep..., middleware: ep.middleware + [mw] }
      else
        ep
    ]
  }
] : Code

-- Mock request handler
handle_request [api: Api, path: String, method: HttpMethod, request: Map ->
  `{
    -- Find the matching endpoint
    endpoint -> api.endpoints |> find [ep -> 
      ep.path == $path and ep.method == $method
    ]
    
    if endpoint is nothing then
      { status: 404, body: "Not Found" }
    else {
      ep -> endpoint |> unwrap
      req -> $request
      
      -- Apply API-wide middleware
      api.middleware |> [mw ->
        req <- mw.handler(req)
      ] |> for_each
      
      -- Apply endpoint-specific middleware
      ep.middleware |> [mw ->
        req <- mw.handler(req)
      ] |> for_each
      
      -- Call the endpoint handler
      response -> ep.handler(req)
      
      -- Return the response
      response
    }
  }
] : Code

-- Example usage of the API DSL
example_api [->
  -- Create a simple blog API
  blog_api -> define_api("BlogAPI", {
    -- Define middleware
    use_middleware("Logger", `{ [req ->
      println("Request: " + req.method + " " + req.path)
      req
    ] }`)
    
    use_middleware("Auth", `{ [req ->
      if req.headers["Authorization"] is nothing then
        { error: "Unauthorized", status: 401 }
      else
        { req..., user: { id: "123", name: "User" } }
    ] }`)
    
    -- Define endpoints
    endpoint("/posts", { GET: () }, `{ [req ->
      { status: 200, body: "List of posts" }
    ] }`)
    
    endpoint("/posts/:id", { GET: () }, `{ [req ->
      id -> req.params["id"]
      { status: 200, body: "Post " + id }
    ] }`)
    
    endpoint("/posts", { POST: () }, `{ [req ->
      -- Create a new post
      { status: 201, body: "Post created" }
    ] }`)
    
    -- Apply middleware to specific endpoints
    apply_middleware("/posts", "Logger")
    apply_middleware("/posts/:id", "Logger")
    apply_middleware("/posts", "Auth")
  })
  
  -- Simulate a request to the API
  request -> {
    path: "/posts",
    method: { GET: () },
    headers: { "Authorization": "Bearer token" }
  }
  
  response -> handle_request(blog_api, "/posts", { GET: () }, request)
  
  "API created with " + (blog_api.endpoints |> length) + " endpoints"
] : String

-- =============================================
-- Main function to demonstrate the DSLs
-- =============================================

main [->
  println("Demonstrating Borf DSLs created with metaprogramming")
  println("====================================================")
  
  println("\n1. Data Model DSL Example:")
  data_model_result -> example_data_model()
  println(data_model_result)
  
  println("\n2. State Machine DSL Example:")
  state_machine_result -> example_state_machine()
  println(state_machine_result)
  
  println("\n3. Web API DSL Example:")
  api_result -> example_api()
  println(api_result)
  
  println("\nAll DSL examples completed successfully.")
] : ()
-- New Borf Syntax Example
-- Demonstrates updated function declarations and type metaprogramming

import prim
import syntax

--[[ 
  This example showcases the updated Borf syntax with:
  1. Name first, then value: "name: value" pattern
  2. Type metaprogramming as the primary way to introduce new types
  3. Concatenative style with pipe operator for data flow
]]--

-- Name: Value Function Declaration Pattern
-- ======================================
-- Instead of value-first declarations:
--   [x, y -> x + y] -> add
-- We now use name-first declarations:
--   add: [x, y -> x y +]

add: [x: Num, y: Num -> 
  x y +
] : Num

-- Multiple parameter functions with explicit types
map: [f: (a) => b, xs: List[a] -> 
  -- Mapping function implementation
  xs is_empty [-> []] when otherwise {
    -- Get head and tail
    head -> xs.head
    tail -> xs.tail
    
    -- Apply function to head and recursively process tail
    head f |> [f_head -> [f_head]] tail f map |> +
  }
] : List[b]

-- Higher-order function with type parameters
compose: [f: (b) => c, g: (a) => b -> 
  -- Return a new function that applies g then f
  [x: a -> 
    x g |> f |>
  ]
] : (a) => c

-- Function with constraints on type parameters
filter: [pred: (a) => Bool, xs: List[a] -> 
  xs is_empty [-> []] when otherwise {
    head -> xs.head
    tail -> xs.tail
    
    -- Keep head if it satisfies predicate
    head pred |> [result -> 
      result [-> [head]] [-> []] when
    ] tail pred filter |> +
  }
] : List[a]

-- Type Metaprogramming for Type Definitions
-- ======================================
-- All types are defined through type metaprogramming

-- Define a custom pair type using type quotation
make_pair_type: [a: Type, b: Type -> 
  #{ 
    first: $a, 
    second: $b
  }
] : Type

-- Create concrete types from the type generator
type IntStringPair => #Int #String make_pair_type |> $

-- Create a pair constructor function with the unified syntax
make_pair: [first: a, second: b -> 
  { first: first, second: second }
] : #a #b make_pair_type |> $

-- Type-level function for creating container types
make_container_type: [value_type: Type -> 
  #{ 
    value: $value_type,
    valid: Bool
  }
] : Type

-- Type-level function for creating sum types
make_sum_type: [left: Type, right: Type -> 
  -- Use type quotation to create a sum type
  #{
    tag: String,
    value: $left | $right
  }
] : Type

-- Use the type constructor with concrete types
type IntOrString => #Int #String make_sum_type |> $

-- Create constructors for the sum type variants
left: [value: a -> 
  { tag: "Left", value: value }
] : #a #b make_sum_type |> $

right: [value: b -> 
  { tag: "Right", value: value }
] : #a #b make_sum_type |> $

-- Quasiquoting for Syntax Extension
-- ==============================

-- Define a new control structure using quasiquoting
when_syntax: [condition, action ->
  -- Use quasiquoting to create a code template
  `{
    { $action } when $condition otherwise { }
  }
] : Code

-- Define a custom loop syntax using quasiquoting
for_each_syntax: [items, variable, body ->
  -- Generate code to loop through items
  `{
    -- Define a recursive helper
    for_helper: [items, process -> 
      {} when items is_empty otherwise {
        head -> items.head
        tail -> items.tail
        
        -- Bind the variable to the current item and run the body
        $variable -> head
        $body
        
        -- Process the rest
        process(tail, process)
      }
    ]
    
    -- Call the helper with the items
    $items |> [items -> items for_helper for_helper |>]
  }
] : Code

-- Example: Using the Extended Syntax
-- ==============================

-- Main function to demonstrate new syntax
main: [-> 
  -- Test the new unified function syntax
  "Adding 5 and 10:" |> print
  5 10 add |> print
  
  -- Create and use a pair with the type generator
  "Creating a pair:" |> print
  pair -> 42 "hello" make_pair |>
  "First: " + pair.first |> print
  "Second: " + pair.second |> print
  
  -- Test the map function
  "Mapping a function over a list:" |> print
  numbers -> [1, 2, 3, 4, 5]
  double: [x -> x 2 *] : Num
  numbers double map |> print
  
  -- Test the filter function
  "Filtering even numbers:" |> print
  is_even: [x -> x 2 % 0 ==] : Bool
  numbers is_even filter |> print
  
  -- Test composition
  "Function composition:" |> print
  increment: [x -> x 1 +] : Num
  increment double compose |> [f -> 5 f |>] |> print
  
  -- Test the when syntax extension
  "Using the when syntax:" |> print
  x -> 10
  -- Expand the when syntax at compile time
  x 5 > {
    "x is greater than 5" |> print
  } when_syntax |> eval
  
  -- Test the for_each syntax extension
  "Using the for_each syntax:" |> print
  items -> ["apple", "banana", "cherry"]
  -- Expand the for_each syntax at compile time
  items item {
    "Processing item: " + item |> print
  } for_each_syntax |> eval
] : ()

-- Type validation helper
is_type: [value, expected_type -> 
  value_type -> value type_of |>
  expected_type value_type teq
] : Bool

-- Debug helper to print type information
debug_type: [value -> 
  type_str -> value type_of |> type_to_string |>
  "Value: " + value + " has type: " + type_str |> print
] : ()
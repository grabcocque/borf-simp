-- Type Metaprogramming in Borf
-- Demonstrates how to use quasiquoting and type quotation

import prim
import syntax

--[[ 
  This example shows how to:
  1. Use quasiquoting to create code templates
  2. Define types programmatically using type quotation
  3. Generate composite types from basic types
  4. Create domain-specific type generators
]]--

-- Basic quasiquoting example
-- ========================
-- Create a template for an addition function
make_adder : (Num) => [Num => Num]
[n -> 
  -- Uses quasiquoting with unquoted value
  `[x -> x + $n]
]

-- Test the adder
add5 -> make_adder(5)
add5_result -> add5(10)  -- Should yield 15

-- Type quotation example
-- ====================
-- Define a type programmatically
-- Type quotation allows types to be first-class values
make_pair_type : (Type, Type) => Type
[t1, t2 -> 
  -- Create a pair type with two components
  #{ first: $t1, second: $t2 }
]

-- Create a Pair[Int, String] type
int_string_pair -> make_pair_type(#Int, #String)

-- Create an instance of the pair type
create_pair : (a, b, Type) => Any
[first, second, pair_type -> 
  -- Create a value of the pair type
  case pair_type of
    #{ first: t1, second: t2 } -> 
      { first: first, second: second }
    _ -> 
      Nothing  -- Not a pair type
]

-- Creating parametric types
-- =======================
-- Define a generic container type
make_container : (Type) => Type
[elem_type -> 
  #{ 
    value: $elem_type,
    valid: Bool
  }
]

-- Define a List type constructor
make_list_type : (Type) => Type
[elem_type -> 
  #List[$elem_type]
]

-- Define a Maybe type constructor
make_maybe_type : (Type) => Type
[elem_type -> 
  #?$elem_type
]

-- Composing type constructors
-- =========================
-- Create a type for a list of optional integers
list_of_optional_ints -> 
  #Int |> make_maybe_type |> make_list_type

-- Create a value of this type
sample_list -> [Nothing, 42, Nothing, 17]

-- Domain-specific type generation
-- ===========================
-- Generate a database record type from a schema
make_record_type : (List[{name: String, type: Type}]) => Type
[fields -> 
  -- Start with an empty record type
  record_type -> #{}
  
  -- Add each field to the record type
  fields |> [fields, field -> 
    -- Extract the field name and type
    name -> field.name
    type -> field.type
    
    -- Add the field to the record type using quasiquoting and unquoting
    #{ $record_type..., $name: $type }
  ] |> fold(record_type)
]

-- Example: Create a Person record type
person_fields -> [
  { name: "name", type: #String },
  { name: "age", type: #Int },
  { name: "email", type: #?String }  -- Optional email
]

person_type -> make_record_type(person_fields)

-- Type functions
-- ============
-- Define a type function that applies a transformation to a type
map_type : (Type, [Type => Type]) => Type
[t, f -> 
  -- Quote the type, apply the function, and unquote the result
  t |> type_quote |> f |> type_unquote
]

-- Define a type transformation that makes any type optional
make_optional : (#Type) => #Type
[t -> #?$t]

-- Apply the transformation to a type
optional_int -> map_type(#Int, make_optional)  -- Should be ?Int

-- Dependent types
-- =============
-- Create a vector type with a fixed length
make_vector_type : (Type, Int) => Type
[elem_type, length -> 
  #Vector[$elem_type, $length]
]

-- Create a 3D vector of integers
vec3i -> make_vector_type(#Int, 3)

-- Create a matrix type with fixed dimensions
make_matrix_type : (Type, Int, Int) => Type
[elem_type, rows, cols -> 
  #Matrix[$elem_type, $rows, $cols]
]

-- Main function to demonstrate type metaprogramming
-- =============================================
main : () => ()
[->
  -- Test the adder
  "Adding 5 to 10:" |> print
  add5(10) |> print
  
  -- Create and show a pair type
  "Creating a pair type:" |> print
  int_string_pair |> print
  
  -- Create an instance of the pair type
  pair -> create_pair(42, "hello", int_string_pair)
  "Pair instance:" |> print
  pair |> print
  
  -- Show the list of optional ints type
  "List of optional ints type:" |> print
  list_of_optional_ints |> print
  
  -- Show the person record type
  "Person record type:" |> print
  person_type |> print
  
  -- Create a person record
  person -> { 
    name: "Alice", 
    age: 30, 
    email: "alice@example.com" 
  }
  "Person instance:" |> print
  person |> print
  
  -- Show the optional int type
  "Optional int type:" |> print
  optional_int |> print
  
  -- Show the 3D vector type
  "3D integer vector type:" |> print
  vec3i |> print
]
-- Borf-in-Borf: A Complete Metacircular Implementation
-- This demonstrates a full implementation of Borf in Borf itself

--[[ 
  This module implements a complete Borf interpreter written in Borf.
  It serves as both a reference implementation and a metacircular evaluator,
  enabling Borf to interpret and run its own code.
  
  This follows the approach used by Lisp and other homoiconic languages
  to create reflective programming systems.
]]--

-- Note: Module declarations and imports can't be properly parsed by the interpreter
-- To fix this, we'll push the module name first and then use the module operation
-- instead of using "module name" syntax directly
-- The following commented lines show the original intention:
-- import prim
-- import syntax
-- module borf_self

-- First, import required modules
"prim" import
"syntax" import

-- Push module name onto stack first, then call module operation
"borf_self" module

-- Type Definitions
-- ==============
-- Represent Borf's core abstractions in itself

-- Create the AST type quotation using quasiquoting
make_ast_type: [->
  `{
    -- Create a type that can represent any Borf AST node
    type BorfAST => #{
      -- Literals
      Num: Int,
      Str: String,
      Sym: String,
      
      -- Core expressions
      Quote: #BorfAST,
      Unquote: #BorfAST,
      Quasiquote: #BorfAST,
      
      -- Type expressions
      TypeQuote: #BorfType,
      TypeUnquote: #BorfAST,
      
      -- Function expressions
      Lambda: { params: List[#BorfParam], body: List[#BorfAST] },
      TypedLambda: { params: List[#BorfParam], body: List[#BorfAST], return_type: #BorfType },
      Apply: { func: #BorfAST, args: List[#BorfAST] },
      
      -- Control flow
      If: { cond: #BorfAST, then_expr: #BorfAST, else_expr: #BorfAST },
      Match: { expr: #BorfAST, patterns: List[{pattern: #BorfPattern, body: #BorfAST}] },
      
      -- Data flow
      Pipe: { left: #BorfAST, right: #BorfAST },
      Assign: { name: String, value: #BorfAST },
      
      -- Module system
      Module: { name: String, imports: List[String], body: List[#BorfAST] },
      Import: String,
      
      -- Type definitions
      TypeDef: { name: String, params: List[#BorfTypeParam], body: #BorfType }
    }
    
    -- Parameter definition
    type BorfParam => #{
      name: String,
      type_annotation: ?#BorfType
    }
    
    -- Type parameter definition
    type BorfTypeParam => #{
      name: String,
      is_linear: Bool
    }
    
    -- Pattern for match expressions
    type BorfPattern => #{
      Wildcard: Unit,
      Literal: #BorfAST,
      Variable: String,
      TypePattern: #BorfType,
      Record: Map[String, #BorfPattern],
      Quoted: #BorfPattern
    }
    
    -- Type representation
    type BorfType => #{
      Simple: String,
      Linear: #BorfType,
      Optional: #BorfType,
      Function: { params: List[#BorfType], return_type: #BorfType },
      Record: Map[String, #BorfType],
      Generic: { name: String, params: List[#BorfType] },
      Union: List[#BorfType]
    }
  }
] : Code

-- Execute the type generator to define our AST types
make_ast_type() eval |>

-- Runtime Value representation
make_value_type: [->
  `{
    -- Runtime value representation
    type BorfValue => #{
      -- Basic values
      Num: Int,
      Str: String,
      Sym: String,
      Bool: Bool,
      
      -- Container values
      List: List[#BorfValue],
      Map: Map[String, #BorfValue],
      
      -- Function values
      Closure: { params: List[#BorfParam], body: List[#BorfAST], env: #BorfEnv },
      TypedClosure: { params: List[#BorfParam], body: List[#BorfAST], return_type: #BorfType, env: #BorfEnv },
      PrimFunction: { name: String, func: (#BorfValue) => #BorfValue },
      
      -- Special values
      Quoted: #BorfValue,
      Type: #BorfType,
      TypeQuoted: #BorfType,
      Module: { name: String, exports: Map[String, #BorfValue] },
      Nothing: Unit,
      
      -- Linear types
      Linear: #BorfValue,
      Consumed: Unit
    }
    
    -- Environment for variable bindings
    type BorfEnv => #{
      bindings: Map[String, #BorfValue],
      parent: ?#BorfEnv
    }
  }
] : Code

-- Execute the value type generator
make_value_type() eval |>

-- Parser Implementation
-- ==================

-- Create a tokenizer for Borf syntax
tokenize: [source: String -> 
  [] : tokens
  "" : current
  false : in_string
  0 : i
  
  -- Tokenize the source code character by character
  while i < source length |> {
    source[i] : char
    
    -- Handle string literals
    if char == "\"" then {
      if in_string then {
        -- End of string
        current + char : current
        tokens + [current] : tokens
        "" : current
        false : in_string
      } else {
        -- Start of string
        if current != "" then {
          tokens + [current] : tokens
          "" : current
        }
        current + char : current
        true : in_string
      }
    } else if in_string then {
      -- Inside a string, just append
      current + char : current
    } else if char == " " or char == "\t" or char == "\n" or char == "\r" then {
      -- Whitespace
      if current != "" then {
        tokens + [current] : tokens
        "" : current
      }
    } else if char == "[" or char == "]" or char == "{" or char == "}" then {
      -- Special brackets
      if current != "" then {
        tokens + [current] : tokens
        "" : current
      }
      tokens + [char] : tokens
    } else {
      -- Regular character
      current + char : current
    }
    
    i + 1 : i
  }
  
  -- Add the last token if any
  if current != "" then
    tokens + [current] : tokens
  
  tokens
] : List[String]

-- Create a parser for Borf source code
parse: [source: String -> 
  source tokenize |> : tokens
  
  tokens is_empty |> if then
    "Empty input" error |>
  
  tokens 0 parse_tokens |> first |>
] : BorfAST

-- Parse tokens into an AST (simplified)
parse_tokens: [tokens: List[String], pos: Int -> 
  pos tokens length |> >= if then
    "Unexpected end of input" error |>
  
  tokens[pos] : token
  
  -- Parse based on token type
  if token |> is_numeric then {
    -- Number literal
    token |> parse_int : num
    { Num: num, pos: pos + 1 }
  } else if token |> starts_with("\"") and token |> ends_with("\"") then {
    -- String literal
    token |> substring(1, token |> length - 2) : str
    { Str: str, pos: pos + 1 }
  } else if token == "[" then {
    -- Quotation/lambda
    parse_lambda(tokens, pos + 1) : result
    { lambda: result.lambda, pos: result.pos }
  } else if token == "{" then {
    -- Record or match expression
    parse_record_or_match(tokens, pos + 1) : result
    { expr: result.expr, pos: result.pos }
  } else if token == "'" then {
    -- Quote
    parse_tokens(tokens, pos + 1) : inner
    { Quote: inner.expr, pos: inner.pos }
  } else if token == "#" then {
    -- Type quote
    parse_type(tokens, pos + 1) : inner
    { TypeQuote: inner.type, pos: inner.pos }
  } else if token == "$" then {
    -- Unquote
    parse_tokens(tokens, pos + 1) : inner
    { Unquote: inner.expr, pos: inner.pos }
  } else {
    -- Symbol or other identifier
    { Sym: token, pos: pos + 1 }
  }
] : { expr: BorfAST, pos: Int }

-- Parse a lambda expression
parse_lambda [tokens: List[String], pos: Int ->
  [] : params
  false : has_arrow
  pos : arrow_pos
  
  -- Look for arrow marker to identify parameters
  while arrow_pos < tokens |> length {
    if tokens[arrow_pos] == "->" then {
      true : has_arrow
      break
    } else if tokens[arrow_pos] == "]" then
      break
    
    arrow_pos + 1 : arrow_pos
  }
  
  pos : new_pos
  
  -- Parse parameters if found
  if has_arrow then {
    tokens |> slice(pos, arrow_pos) : param_tokens
    parse_parameters(param_tokens) : params
    arrow_pos + 1 : new_pos  -- Skip the arrow
  }
  
  -- Parse the body expressions
  [] : body
  new_pos : current_pos
  
  while current_pos < tokens |> length {
    if tokens[current_pos] == "]" then {
      -- End of lambda
      current_pos + 1 : current_pos
      
      -- Check for type annotation (using <: syntax)
      if current_pos < tokens |> length and tokens[current_pos] == "<:" then {
        -- TypedLambda with return type
        parse_type(tokens, current_pos + 1) : type_result
        return { 
          lambda: { TypedLambda: { params: params, body: body, return_type: type_result.type }},
          pos: type_result.pos
        }
      } else {
        -- Regular lambda
        return { 
          lambda: { Lambda: { params: params, body: body }},
          pos: current_pos
        }
      }
    } else {
      -- Parse a body expression
      parse_tokens(tokens, current_pos) : expr_result
      body + [expr_result.expr] : body
      expr_result.pos : current_pos
    }
  }
  
  error("Unclosed lambda expression")
] : { lambda: BorfAST, pos: Int }

-- Parse parameters for a lambda
parse_parameters [tokens: List[String] ->
  [] : params
  0 : i
  
  while i < tokens |> length {
    tokens[i] : token
    
    if token == "," then {
      -- Skip comma
      i + 1 : i
    } else {
      -- Parameter name
      token : name
      nothing : type_ann
      
      -- Check for type annotation (using <: syntax)
      if i + 2 < tokens |> length and tokens[i + 1] == "<:" then {
        i + 2 : i  -- Skip the type annotation marker
        parse_type(tokens, i) : type_result
        type_result.type |> some : type_ann
        type_result.pos : i
      } else {
        i + 1 : i
      }
      
      params + [{ name: name, type_annotation: type_ann }] : params
    }
  }
  
  params
] : List[BorfParam]

-- Parse a type expression
parse_type [tokens: List[String], pos: Int ->
  if pos >= tokens |> length then
    error("Unexpected end of input in type")
  
  tokens[pos] : token
  
  if token == "?" then {
    -- Optional type
    parse_type(tokens, pos + 1) : inner
    { type: { Optional: inner.type }, pos: inner.pos }
  } else if token == "!" then {
    -- Linear type
    parse_type(tokens, pos + 1) : inner
    { type: { Linear: inner.type }, pos: inner.pos }
  } else if token == "(" then {
    -- Function type
    parse_function_type(tokens, pos + 1)
  } else if token == "{" then {
    -- Record type
    parse_record_type(tokens, pos + 1)
  } else {
    -- Simple type or generic
    if pos + 1 < tokens |> length and tokens[pos + 1] == "[" then {
      -- Generic type with parameters
      token : name
      parse_type_params(tokens, pos + 2) : params_result
      { type: { Generic: { name: name, params: params_result.params }}, pos: params_result.pos }
    } else {
      -- Simple type name
      { type: { Simple: token }, pos: pos + 1 }
    }
  }
] : { type: BorfType, pos: Int }

-- Parse function type parameters
parse_function_type [tokens: List[String], pos: Int ->
  [] : params
  pos : current_pos
  
  -- Parse parameter types
  while current_pos < tokens |> length {
    if tokens[current_pos] == ")" then {
      -- End of parameters, look for =>
      current_pos + 1 : current_pos
      
      if current_pos < tokens |> length and tokens[current_pos] == "=>" then {
        -- Parse return type
        parse_type(tokens, current_pos + 1) : return_result
        return { 
          type: { Function: { params: params, return_type: return_result.type }},
          pos: return_result.pos
        }
      } else {
        error("Expected => after ) in function type")
      }
    } else if tokens[current_pos] == "," then {
      -- Skip comma
      current_pos + 1 : current_pos
    } else {
      -- Parse parameter type
      parse_type(tokens, current_pos) : param_result
      params + [param_result.type] : params
      param_result.pos : current_pos
    }
  }
  
  error("Unclosed function type")
] : { type: BorfType, pos: Int }

-- Parse record type
parse_record_type [tokens: List[String], pos: Int ->
  {} : fields
  pos : current_pos
  
  while current_pos < tokens |> length {
    if tokens[current_pos] == "}" then {
      -- End of record
      return { type: { Record: fields }, pos: current_pos + 1 }
    } else if tokens[current_pos] == "," then {
      -- Skip comma
      current_pos + 1 : current_pos
    } else {
      -- Field name
      tokens[current_pos] : name
      
      -- Expect colon
      if current_pos + 1 >= tokens |> length or tokens[current_pos + 1] != ":" then
        error("Expected : after field name in record type")
      
      -- Parse field type
      parse_type(tokens, current_pos + 2) : type_result
      fields |> insert(name, type_result.type) : fields
      type_result.pos : current_pos
    }
  }
  
  error("Unclosed record type")
] : { type: BorfType, pos: Int }

-- Parse record or match expression
parse_record_or_match [tokens: List[String], pos: Int ->
  -- This is a placeholder for parsing record literals or match expressions
  -- In a complete implementation, we would distinguish between them
  -- For this example, we'll just assume it's a record literal
  
  {} : fields
  pos : current_pos
  
  while current_pos < tokens |> length {
    if tokens[current_pos] == "}" then {
      -- End of record
      return { expr: { Sym: "record" }, pos: current_pos + 1 }
    } else if tokens[current_pos] == "," then {
      -- Skip comma
      current_pos + 1 : current_pos
    } else {
      -- Field name or pattern
      parse_tokens(tokens, current_pos) : field_expr
      field_expr.pos : current_pos
    }
  }
  
  error("Unclosed record or match expression")
] : { expr: BorfAST, pos: Int }

-- Parse generic type parameters
parse_type_params [tokens: List[String], pos: Int ->
  [] : params
  pos : current_pos
  
  while current_pos < tokens |> length {
    if tokens[current_pos] == "]" then {
      -- End of parameters
      return { params: params, pos: current_pos + 1 }
    } else if tokens[current_pos] == "," then {
      -- Skip comma
      current_pos + 1 : current_pos
    } else {
      -- Parse parameter type
      parse_type(tokens, current_pos) : param_result
      params + [param_result.type] : params
      param_result.pos : current_pos
    }
  }
  
  error("Unclosed generic type parameters")
] : { params: List[BorfType], pos: Int }

-- Evaluator Implementation
-- =====================

-- Create a new empty environment
new_env: [->
  { bindings: {}, parent: nothing }
] : BorfEnv

-- Create a child environment with a parent
new_env_with_parent: [parent: BorfEnv ->
  { bindings: {}, parent: parent some |> }
] : BorfEnv

-- Look up a variable in the environment
lookup: [env: BorfEnv, name: String ->
  env.bindings name has_key |> if then
    env.bindings[name] some |>
  else if env.parent some is then
    env.parent unwrap |> name lookup |>
  else
    nothing
] : ?BorfValue

-- Define or update a variable in the environment
define: [env: BorfEnv, name: String, value: BorfValue ->
  env.bindings name value insert |> : env.bindings
  env
] : BorfEnv

-- Evaluate an expression in an environment
evaluate: [expr: BorfAST, env: BorfEnv ->
  expr case of
    { Num: n } -> { Num: n }
    { Str: s } -> { Str: s }
    { Sym: name } -> 
      env name lookup |> match {
        | some(value) -> value
        | nothing -> "Undefined variable: " + name error |>
      }
    
    { Quote: inner } -> { Quoted: inner env evaluate |> }
    { Unquote: inner } -> 
      -- Unquote a quoted value
      inner env evaluate |> : quoted
      quoted { Quoted: value } is if then
        value
      else
        "Cannot unquote non-quoted value" error |>
    
    { TypeQuote: typ } -> { TypeQuoted: typ }
    
    { Lambda: l } -> 
      -- Create a closure with the current environment
      { Closure: { params: l.params, body: l.body, env: env }}
    
    { TypedLambda: l } -> 
      -- Create a typed closure with the current environment
      { TypedClosure: { 
        params: l.params, 
        body: l.body, 
        return_type: l.return_type, 
        env: env 
      }}
    
    { Apply: a } -> 
      -- Evaluate function and arguments
      a.func env evaluate |> : func
      a.args [arg -> arg env evaluate |>] map |> : args
      
      -- Apply the function
      func args env apply_function |>
    
    { If: i } -> 
      -- Evaluate condition
      i.cond env evaluate |> : cond_value
      
      -- Check truth value
      cond_value is_truthy |> if then
        i.then_expr env evaluate |>
      else
        i.else_expr env evaluate |>
    
    { Match: m } -> 
      -- Evaluate the expression to match against
      m.expr env evaluate |> : value
      
      -- Try each pattern
      false : matched
      { Nothing: () } : result
      
      m.patterns [pattern ->
        matched not if then {
          value pattern.pattern env match_pattern |> : match_result
          
          match_result.matched if then {
            -- Pattern matched, evaluate the body with the match bindings
            pattern.body match_result.env evaluate |> : result
            true : matched
          }
        }
      ] for_each |>
      
      -- Check if any pattern matched
      matched if then
        result
      else
        "No pattern matched the value" error |>
    
    { Pipe: p } -> 
      -- Evaluate left side
      p.left env evaluate |> : left_value
      
      -- Apply to right side based on what it is
      p.right case of
        { Sym: func_name } -> 
          -- Look up function and apply
          env func_name lookup |> match {
            | some(func) -> func [left_value] env apply_function |>
            | nothing -> "Undefined function in pipeline: " + func_name error |>
          }
        
        { Apply: apply } -> 
          -- Function application with additional arguments
          apply.func env evaluate |> : func
          apply.args [arg -> arg env evaluate |>] map |> : args
          func [left_value] args + env apply_function |>
        
        _ -> 
          -- Evaluate as function and apply to left value
          p.right env evaluate |> : func
          func [left_value] env apply_function |>
    
    { Assign: a } -> 
      -- Evaluate the value
      a.value env evaluate |> : value
      
      -- Define in the environment
      env a.name value define |>
      
      -- Return the value
      value
    
    { Module: m } -> 
      -- Process module definition
      -- Create a new environment for the module
      env new_env_with_parent |> : module_env
      m.name : module_name
      
      -- Register in global modules registry early to allow recursive references
      { Module: { name: module_name, exports: {} }} : module_obj
      module_name module_obj register_module |>
      
      -- Process imports
      m.imports [import_name ->
        -- Import module exports into the module environment
        import_name module_env import_module |>
      ] for_each |>
      
      -- Evaluate module body
      {} : exports
      
      m.body [expr ->
        expr module_env evaluate |> : result
        
        -- If it's an assignment, add to exports
        expr { Assign: a } is if then
          exports a.name result insert |> : exports
      ] for_each |>
      
      -- Create the final module object with all exports
      { Module: { name: module_name, exports: exports }} : module_obj
      
      -- Update the registration with complete exports
      module_name module_obj register_module |>
      
      -- Return the module value
      module_obj
    
    { Import: module_name } -> 
      -- Import a module's exports into the current environment
      module_name env import_module |>
      { Nothing: () }
    
    { TypeDef: td } -> 
      -- Evaluate the type definition
      -- In a full implementation, this would register the type
      -- and its constructor in the environment
      type_name -> td.name
      type_def -> td.type_def
      
      -- Register the type in the environment
      env type_name { Type: type_def } define |>
      
      -- Return nothing
      { Nothing: () }
    
    _ -> "Unsupported expression type: " + expr to_string |> error |>
] : BorfValue

-- Apply a function to arguments
apply_function: [func: BorfValue, args: List[BorfValue], env: BorfEnv ->
  func case of
    { Closure: c } -> 
      -- Create a new environment with the closure's environment as parent
      c.env new_env_with_parent |> : call_env
      
      -- Bind arguments to parameters
      args length |> c.params length |> != if then
        "Wrong number of arguments: expected " + c.params length |> to_string |> + 
        ", got " + args length |> to_string |> error |>
      
      -- Bind each parameter
      c.params args zip |> [pair ->
        pair.0 : param
        pair.1 : arg
        call_env param.name arg define |>
      ] for_each |>
      
      -- Evaluate body expressions
      { Nothing: () } : result
      
      c.body [expr ->
        expr call_env evaluate |> : result
      ] for_each |>
      
      result
    
    { TypedClosure: tc } -> 
      -- Same as regular closure but with type checking
      -- In a full implementation, would verify argument types
      tc.env new_env_with_parent |> : call_env
      
      args length |> tc.params length |> != if then
        "Wrong number of arguments: expected " + tc.params length |> to_string |> + 
        ", got " + args length |> to_string |> error |>
      
      tc.params args zip |> [pair ->
        pair.0 : param
        pair.1 : arg
        call_env param.name arg define |>
      ] for_each |>
      
      { Nothing: () } : result
      
      tc.body [expr ->
        expr call_env evaluate |> : result
      ] for_each |>
      
      -- In a full implementation, verify result type matches return_type
      result
    
    { PrimFunction: pf } -> 
      -- Call primitive function with arguments
      args length |> 1 != if then
        -- For simplicity, all primitive functions take a single argument
        -- which can be a list of actual arguments
        { List: args } pf.func |>
      else
        args[0] pf.func |>
    
    _ -> "Cannot apply non-function value: " + func to_string |> error |>
] : BorfValue

-- Match a value against a pattern
match_pattern: [value: BorfValue, pattern: BorfPattern, env: BorfEnv ->
  -- Create a new environment for pattern bindings
  env new_env_with_parent |> : match_env
  false : matched
  
  pattern case of
    { Wildcard: () } -> 
      -- Wildcard matches anything
      true : matched
    
    { Literal: lit } -> 
      -- Match against a literal value
      lit env evaluate |> : lit_value
      value lit_value values_equal |> : matched
    
    { Variable: name } -> 
      -- Bind the value to the variable name
      match_env name value define |>
      true : matched
    
    { TypePattern: t } -> 
      -- Match based on type
      value type_of |> : value_type
      value_type t types_equal |> : matched
    
    { Record: fields } -> 
      -- Match against a record pattern
      value { Map: value_map } is if then {
        true : matched
        
        -- Each field in the pattern must match
        fields [name, pattern ->
          matched not if then
            return
          
          value_map name has_key |> if then {
            value_map[name] pattern match_env match_pattern |> : field_result
            field_result.matched not if then
              false : matched
            else {
              -- Merge bindings from field match
              field_result.env.bindings [binding_name, binding_value ->
                match_env binding_name binding_value define |>
              ] for_each |>
            }
          } else {
            false : matched
          }
        ] for_each |>
      } else {
        false : matched
      }
    
    { Quoted: inner_pattern } -> 
      -- Match against a quoted pattern
      value { Quoted: inner_value } is if then {
        inner_value inner_pattern match_env match_pattern |> : inner_result
        inner_result.matched : matched
        
        -- Merge bindings from inner match
        matched if then {
          inner_result.env.bindings [name, val ->
            match_env name val define |>
          ] for_each |>
        }
      } else {
        false : matched
      }
  }
  
  { matched: matched, env: match_env }
] : { matched: Bool, env: BorfEnv }

-- Import a module
import_module: [module_name: String, env: BorfEnv ->
  -- Expanded module system that supports both built-in and user-defined modules
  module_value -> module_name find_module |>
  
  if module_value is some then {
    -- Load a registered module
    module -> module_value unwrap |>
    
    -- Add exports to the environment
    if module is { Module: m } then {
      m.exports [name, value ->
        env name value define |>
      ] for_each |>
    }
  } else if module_name == "core" then {
    -- Define core functions
    env "add" "add" [a, b -> 
      if a is { Num: n1 } and b is { Num: n2 } then
        { Num: n1 + n2 }
      else
        "add requires numbers" error |>
    ] make_primitive |> define |>
    
    env "sub" "sub" [a, b -> 
      if a is { Num: n1 } and b is { Num: n2 } then
        { Num: n1 - n2 }
      else
        "sub requires numbers" error |>
    ] make_primitive |> define |>
    
    env "mul" "mul" [a, b -> 
      if a is { Num: n1 } and b is { Num: n2 } then
        { Num: n1 * n2 }
      else
        "mul requires numbers" error |>
    ] make_primitive |> define |>
    
    env "div" "div" [a, b -> 
      if a is { Num: n1 } and b is { Num: n2 } then
        if b is { Num: 0 } then
          "division by zero" error |>
        else
          { Num: n1 / n2 }
      else
        "div requires numbers" error |>
    ] make_primitive |> define |>
    
    env "print" "print" [value -> 
      value value_to_string |> println |>
      { Nothing: () }
    ] make_primitive |> define |>
    
    env "println" "println" [value -> 
      value value_to_string |> println |>
      { Nothing: () }
    ] make_primitive |> define |>
    
    -- Collections
    env "list" "list" [items -> 
      items
    ] make_primitive |> define |>
    
    env "map" "map" [entries -> 
      entries { List: items } is if then {
        {} : result
        
        -- Expect pairs of key, value
        items length |> 2 % 0 != if then
          "map requires pairs of key, value" error |>
        
        0 : i
        i items length |> < while {
          items[i] : key
          items[i + 1] : value
          
          key { Str: k } is if then
            result k value insert |> : result
          else
            "map keys must be strings" error |>
          
          i + 2 : i
        }
        
        { Map: result }
      } else
        "map requires a list of key-value pairs" error |>
    ] make_primitive |> define |>
  } else if module_name == "meta" then {
    -- Define metaprogramming functions
    env "eval" "eval" [code -> 
      code { Quoted: value } is if then {
        value { Str: source } is if then {
          -- Parse and evaluate string code
          ast -> source parse |>
          ast env evaluate |>
        } else {
          -- Evaluate AST node directly
          value env evaluate |>
        }
      } else {
        "eval requires quoted code" error |>
      }
    ] make_primitive |> define |>
    
    env "parse" "parse" [source -> 
      source { Str: code } is if then
        code parse |>
      else
        "parse requires a string" error |>
    ] make_primitive |> define |>
    
    env "quote" "quote" [value -> 
      { Quoted: value }
    ] make_primitive |> define |>
    
    env "unquote" "unquote" [quoted -> 
      quoted { Quoted: value } is if then
        value
      else
        "unquote requires a quoted value" error |>
    ] make_primitive |> define |>
    
    env "type_of" "type_of" [value -> 
      { Type: value type_of |> }
    ] make_primitive |> define |>
    
    env "type" "type" [value -> 
      { Type: value type_of |> }
    ] make_primitive |> define |>
    
    env "type_equals" "type_equals" [t1, t2 -> 
      t1 { Type: type1 } is t2 { Type: type2 } is and if then
        { Bool: type1 type2 types_equal |> }
      else
        "type_equals requires two type values" error |>
    ] make_primitive |> define |>
    
    env "type_to_string" "type_to_string" [type_val -> 
      type_val { Type: t } is if then
        { Str: t type_to_string |> }
      else
        "type_to_string requires a type value" error |>
    ] make_primitive |> define |>
    
    -- For the borf-in-borf-in-borf test
    env "eval1" "eval1" [code, env_val -> 
      -- This is a wrapper around eval for the multi-level evaluator test
      code { Quoted: source } is env_val { Map: _ } is and if then {
        -- Parse and evaluate the code in the given environment
        source parse |> : ast
        ast env_val evaluate |>
      } else {
        "eval1 requires quoted code and an environment" error |>
      }
    ] make_primitive |> define |>
    
    env "generate_and_eval" "generate_and_eval" [template, value -> 
      -- Generate code by substituting value into template and evaluate it
      template { Str: t } is if then {
        -- Simple template substitution (in a real impl, would be more sophisticated)
        code : t value value_to_string |> replace("$VALUE", _)
        -- Parse and evaluate the generated code
        code parse |> : ast
        ast env evaluate |>
      } else {
        "generate_and_eval requires a string template" error |>
      }
    ] make_primitive |> define |>
  } else if module_name == "prim" then {
    -- Define primitive operations
    env "to_string" "to_string" [value -> 
      { Str: value value_to_string |> }
    ] make_primitive |> define |>
    
    env "parse_int" "parse_int" [str -> 
      str { Str: s } is if then {
        n -> s try_parse_int |>
        n some is if then
          { Num: n unwrap |> }
        else
          "could not parse integer: " + s error |>
      } else
        "parse_int requires a string" error |>
    ] make_primitive |> define |>
    
    env "is_numeric" "is_numeric" [value -> 
      value { Str: s } is if then
        { Bool: s is_numeric |> }
      else
        { Bool: false }
    ] make_primitive |> define |>
    
    env "length" "length" [coll -> 
      coll { List: items } is if then
        { Num: items length |> }
      else if coll { Str: s } is then
        { Num: s length |> }
      else if coll { Map: m } is then
        { Num: m keys |> length |> }
      else
        "length requires a collection" error |>
    ] make_primitive |> define |>
    
    env "starts_with" "starts_with" [str, prefix -> 
      str { Str: s } is prefix { Str: p } is and if then
        { Bool: s p starts_with |> }
      else
        "starts_with requires two strings" error |>
    ] make_primitive |> define |>
    
    env "ends_with" "ends_with" [str, suffix -> 
      str { Str: s } is suffix { Str: sf } is and if then
        { Bool: s sf ends_with |> }
      else
        "ends_with requires two strings" error |>
    ] make_primitive |> define |>
    
    env "substring" "substring" [str, start, end -> 
      str { Str: s } is start { Num: st } is end { Num: e } is and and if then
        { Str: s st e substring |> }
      else
        "substring requires a string and two numbers" error |>
    ] make_primitive |> define |>
    
    env "replace" "replace" [str, search, replace_with -> 
      str { Str: s } is search { Str: f } is replace_with { Str: r } is and and if then {
        -- Simple replacement (in a real impl, would be more efficient)
        result : ""
        start_idx : 0
        
        -- Find and replace all occurrences
        while true {
          idx : s f start_idx indexOf |>
          
          if idx < 0 then {
            -- No more occurrences, add remaining string
            result + (s start_idx s length |> substring |>) : result
            break
          }
          
          -- Add everything up to match + the replacement
          result + (s start_idx idx substring |>) + r : result
          
          -- Move past this occurrence
          idx + f length |> : start_idx
        }
        
        { Str: result }
      } else
        "replace requires three strings" error |>
    ] make_primitive |> define |>
  } else if module_name == "syntax" then {
    -- Define syntax-related functions
    env "parse" "parse" [source -> 
      source { Str: code } is if then
        code parse |>
      else
        "parse requires a string" error |>
    ] make_primitive |> define |>
    
    env "read_file" "read_file" [path -> 
      path { Str: p } is if then {
        content -> p read_file |>
        content some is if then
          { Str: content unwrap |> }
        else
          "could not read file: " + p error |>
      } else
        "read_file requires a string path" error |>
    ] make_primitive |> define |>
  } else {
    -- Try to load the module from file
    file_path -> "src/prelude/" + module_name + "/" + module_name + ".borf"
    content -> file_path read_file |>
    
    content some is if then {
      -- Parse and evaluate the module file
      module_code -> content unwrap |>
      module_ast -> module_code parse |>
      
      -- Evaluate the module
      module_result -> module_ast env evaluate |>
      
      -- Register the module
      module_name module_result register_module |>
      
      -- Set up exports if it's a proper module
      module_result { Module: m } is if then {
        m.exports [name, value ->
          env name value define |>
        ] for_each |>
      }
    } else {
      "Unknown module: " + module_name + " (tried path: " + file_path + ")" error |>
    }
  }
  
  env
] : BorfEnv

-- Module registry for caching loaded modules
module_registry -> {}

-- Find a module in the registry
find_module: [name: String ->
  if module_registry has_key(name) then
    module_registry[name] some |>
  else
    nothing
] : ?BorfValue

-- Register a module in the registry
register_module: [name: String, module: BorfValue ->
  module_registry name module insert |> : module_registry
] : ()

-- Host operations that delegate to the runtime
-- These are implemented by the host Borf runtime

-- Read file helper - delegates to the host runtime's file reading
read_file: [path: String ->
  -- This is implemented by the host Borf runtime
  -- In our metacircular evaluator, we'll rely on the host's implementation
  try {
    content -> path native_read_file |>
    content some |>
  } catch e {
    nothing
  }
] : ?String

-- Try to parse an integer
try_parse_int: [s: String ->
  -- This is implemented by the host Borf runtime
  try {
    n -> s native_parse_int |>
    n some |>
  } catch e {
    nothing
  }
] : ?Int

-- String helper functions
is_numeric: [s: String ->
  -- Simple implementation checking if the string contains only digits
  s length |> 0 > s chars |> [c -> c '0' >= c '9' <= and] all |> and
] : Bool

starts_with: [s: String, prefix: String ->
  s length |> prefix length |> < if then
    false
  else
    s 0 prefix length |> substring |> prefix veq
] : Bool

ends_with: [s: String, suffix: String ->
  s length |> suffix length |> < if then
    false
  else
    s s length |> suffix length |> - s length |> substring |> suffix veq
] : Bool

indexOf: [s: String, search: String, start: Int ->
  -- Find index of substring, starting from position start
  -- Return -1 if not found
  -- This is implemented by the host Borf runtime
  s search start native_index_of |>
] : Int

substring: [s: String, start: Int, end: Int ->
  -- This is implemented by the host Borf runtime
  s start end native_substring |>
] : String

-- Create a primitive function
make_primitive: [name: String, func: (BorfValue) => BorfValue ->
  { PrimFunction: { name: name, func: func }}
] : BorfValue

-- Check if a value is truthy
is_truthy: [value: BorfValue ->
  value case of
    { Num: n } -> n 0 !=
    { Str: s } -> s "" !=
    { Bool: b } -> b
    { List: items } -> items is_empty |> not
    { Nothing: () } -> false
    _ -> true
] : Bool

-- Get the type of a value
type_of: [value: BorfValue ->
  value case of
    { Num: _ } -> { Simple: "Num" }
    { Str: _ } -> { Simple: "String" }
    { Bool: _ } -> { Simple: "Bool" }
    { List: _ } -> { Generic: { name: "List", params: [{ Simple: "Any" }] }}
    { Map: _ } -> { Simple: "Map" }
    { Closure: _ } -> { Simple: "Function" }
    { TypedClosure: c } -> { Function: { params: [], return_type: c.return_type }}
    { Module: _ } -> { Simple: "Module" }
    { Nothing: () } -> { Simple: "Nothing" }
    _ -> { Simple: "Any" }
] : BorfType

-- Check if two values are equal
values_equal [a: BorfValue, b: BorfValue ->
  case (a, b) of
    ({ Num: n1 }, { Num: n2 }) -> n1 == n2
    ({ Str: s1 }, { Str: s2 }) -> s1 == s2
    ({ Bool: b1 }, { Bool: b2 }) -> b1 == b2
    ({ Nothing: () }, { Nothing: () }) -> true
    _ -> false
] : Bool

-- Check if two types are equal
types_equal [a: BorfType, b: BorfType ->
  case (a, b) of
    ({ Simple: s1 }, { Simple: s2 }) -> s1 == s2
    ({ Linear: l1 }, { Linear: l2 }) -> types_equal(l1, l2)
    ({ Optional: o1 }, { Optional: o2 }) -> types_equal(o1, o2)
    ({ Generic: g1 }, { Generic: g2 }) -> 
      g1.name == g2.name and g1.params |> length == g2.params |> length and
      (g1.params |> zip(g2.params) |> all [pair -> types_equal(pair.0, pair.1)])
    ({ Function: f1 }, { Function: f2 }) ->
      f1.params |> length == f2.params |> length and
      f1.params |> zip(f2.params) |> all [pair -> types_equal(pair.0, pair.1)] and
      types_equal(f1.return_type, f2.return_type)
    ({ Record: r1 }, { Record: r2 }) ->
      r1 |> keys |> set_equals(r2 |> keys) and
      r1 |> all [k, v -> r2 |> has_key(k) and types_equal(v, r2[k])]
    _ -> false
] : Bool

-- Convert a value to a string representation
value_to_string [value: BorfValue ->
  case value of
    { Num: n } -> n |> to_string
    { Str: s } -> "\"" + s + "\""
    { Bool: b } -> b |> to_string
    { List: items } -> 
      "[" + (items |> map(value_to_string) |> join(", ")) + "]"
    { Map: entries } -> 
      "{" + (entries |> map [k, v -> k + ": " + value_to_string(v)] |> join(", ")) + "}"
    { Closure: _ } -> "[function]"
    { TypedClosure: c } -> "[function: " + type_to_string(c.return_type) + "]"
    { PrimFunction: p } -> "[primitive: " + p.name + "]"
    { Quoted: v } -> "'" + value_to_string(v)
    { TypeQuoted: t } -> "#" + type_to_string(t)
    { Module: m } -> "module " + m.name
    { Nothing: () } -> "nothing"
    _ -> "[value]"
] : String

-- Convert a type to a string representation
type_to_string [type: BorfType ->
  case type of
    { Simple: name } -> name
    { Linear: inner } -> "!" + type_to_string(inner)
    { Optional: inner } -> "?" + type_to_string(inner)
    { Generic: g } -> 
      g.name + "[" + (g.params |> map(type_to_string) |> join(", ")) + "]"
    { Function: f } -> 
      "(" + (f.params |> map(type_to_string) |> join(", ")) + 
      ") => " + type_to_string(f.return_type)
    { Record: fields } -> 
      "{" + (fields |> map [k, v -> k + ": " + type_to_string(v)] |> join(", ")) + "}"
    { Union: types } -> 
      types |> map(type_to_string) |> join(" | ")
  }
] : String

-- REPL Implementation
-- =================

-- Create a REPL for interactive Borf evaluation
borf_repl [->
  new_env() : env
  
  -- Initialize with standard libraries
  import_module("core", env)
  import_module("meta", env)
  
  println("Borf-in-Borf REPL")
  println("Type 'exit' to quit")
  
  while true {
    print("borf> ")
    read_line() : input
    
    if input == "exit" then
      break
    
    try {
      -- Parse the input
      parse(input) : ast
      
      -- Evaluate the expression
      evaluate(ast, env) : result
      
      -- Print the result
      println("=> " + value_to_string(result))
    } catch error {
      println("Error: " + error)
    }
  }
] : ()

-- Example code that demonstrates self-evaluation
-- =========================================

-- Example 1: Basic self-evaluation
example1 [->
  -- Initialize environment
  new_env() : env
  import_module("core", env)
  
  -- Define a simple expression in Borf syntax
  "5 10 add" : code
  
  -- Parse the code into an AST
  parse(code) : ast
  
  -- Evaluate the AST
  evaluate(ast, env) : result
  
  -- Print the result
  println("Example 1 result: " + value_to_string(result))
] : ()

-- Example 2: Metaprogramming with self-evaluation
example2 [->
  -- Initialize environment
  new_env() : env
  import_module("core", env)
  import_module("meta", env)
  
  -- Define code that generates code
  "
    [x -> 
      [y -> x y add]
    ] : make_adder
    
    5 make_adder : add5
    10 add5
  " : meta_code
  
  -- Parse and evaluate the metaprogramming code
  parse(meta_code) : ast
  evaluate(ast, env) : result
  
  -- Print the result
  println("Example 2 result: " + value_to_string(result))
] : ()

-- Example 3: Type metaprogramming
example3 [->
  -- Initialize environment
  new_env() : env
  import_module("core", env)
  import_module("meta", env)
  
  -- Define code that generates a type
  "
    [t1, t2 -> 
      #{ first: $t1, second: $t2 }
    ] : make_pair_type
    
    #Int #String make_pair_type : int_string_pair
    
    int_string_pair
  " : type_code
  
  -- Parse and evaluate
  parse(type_code) : ast
  evaluate(ast, env) : result
  
  -- Print the result
  println("Example 3 result: " + value_to_string(result))
] : ()

-- Main function to run the examples
main [->
  println("Running Borf-in-Borf examples...")
  
  -- Run the examples
  example1()
  example2()
  example3()
  
  -- Run the REPL if requested
  if args |> contains("--repl") then
    borf_repl()
  
  println("Borf-in-Borf completed successfully.")
] : ()